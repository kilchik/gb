package main

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i l3/cmd/minimock.DB -o ./db_mock_test.go

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// DBMock implements DB
type DBMock struct {
	t minimock.Tester

	funcGetOrderItems          func(oid uint64) (ua1 []uint64, err error)
	inspectFuncGetOrderItems   func(oid uint64)
	afterGetOrderItemsCounter  uint64
	beforeGetOrderItemsCounter uint64
	GetOrderItemsMock          mDBMockGetOrderItems

	funcGetUserName          func(uid uint64) (s1 string, err error)
	inspectFuncGetUserName   func(uid uint64)
	afterGetUserNameCounter  uint64
	beforeGetUserNameCounter uint64
	GetUserNameMock          mDBMockGetUserName
}

// NewDBMock returns a mock for DB
func NewDBMock(t minimock.Tester) *DBMock {
	m := &DBMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetOrderItemsMock = mDBMockGetOrderItems{mock: m}
	m.GetOrderItemsMock.callArgs = []*DBMockGetOrderItemsParams{}

	m.GetUserNameMock = mDBMockGetUserName{mock: m}
	m.GetUserNameMock.callArgs = []*DBMockGetUserNameParams{}

	return m
}

type mDBMockGetOrderItems struct {
	mock               *DBMock
	defaultExpectation *DBMockGetOrderItemsExpectation
	expectations       []*DBMockGetOrderItemsExpectation

	callArgs []*DBMockGetOrderItemsParams
	mutex    sync.RWMutex
}

// DBMockGetOrderItemsExpectation specifies expectation struct of the DB.GetOrderItems
type DBMockGetOrderItemsExpectation struct {
	mock    *DBMock
	params  *DBMockGetOrderItemsParams
	results *DBMockGetOrderItemsResults
	Counter uint64
}

// DBMockGetOrderItemsParams contains parameters of the DB.GetOrderItems
type DBMockGetOrderItemsParams struct {
	oid uint64
}

// DBMockGetOrderItemsResults contains results of the DB.GetOrderItems
type DBMockGetOrderItemsResults struct {
	ua1 []uint64
	err error
}

// Expect sets up expected params for DB.GetOrderItems
func (mmGetOrderItems *mDBMockGetOrderItems) Expect(oid uint64) *mDBMockGetOrderItems {
	if mmGetOrderItems.mock.funcGetOrderItems != nil {
		mmGetOrderItems.mock.t.Fatalf("DBMock.GetOrderItems mock is already set by Set")
	}

	if mmGetOrderItems.defaultExpectation == nil {
		mmGetOrderItems.defaultExpectation = &DBMockGetOrderItemsExpectation{}
	}

	mmGetOrderItems.defaultExpectation.params = &DBMockGetOrderItemsParams{oid}
	for _, e := range mmGetOrderItems.expectations {
		if minimock.Equal(e.params, mmGetOrderItems.defaultExpectation.params) {
			mmGetOrderItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrderItems.defaultExpectation.params)
		}
	}

	return mmGetOrderItems
}

// Inspect accepts an inspector function that has same arguments as the DB.GetOrderItems
func (mmGetOrderItems *mDBMockGetOrderItems) Inspect(f func(oid uint64)) *mDBMockGetOrderItems {
	if mmGetOrderItems.mock.inspectFuncGetOrderItems != nil {
		mmGetOrderItems.mock.t.Fatalf("Inspect function is already set for DBMock.GetOrderItems")
	}

	mmGetOrderItems.mock.inspectFuncGetOrderItems = f

	return mmGetOrderItems
}

// Return sets up results that will be returned by DB.GetOrderItems
func (mmGetOrderItems *mDBMockGetOrderItems) Return(ua1 []uint64, err error) *DBMock {
	if mmGetOrderItems.mock.funcGetOrderItems != nil {
		mmGetOrderItems.mock.t.Fatalf("DBMock.GetOrderItems mock is already set by Set")
	}

	if mmGetOrderItems.defaultExpectation == nil {
		mmGetOrderItems.defaultExpectation = &DBMockGetOrderItemsExpectation{mock: mmGetOrderItems.mock}
	}
	mmGetOrderItems.defaultExpectation.results = &DBMockGetOrderItemsResults{ua1, err}
	return mmGetOrderItems.mock
}

//Set uses given function f to mock the DB.GetOrderItems method
func (mmGetOrderItems *mDBMockGetOrderItems) Set(f func(oid uint64) (ua1 []uint64, err error)) *DBMock {
	if mmGetOrderItems.defaultExpectation != nil {
		mmGetOrderItems.mock.t.Fatalf("Default expectation is already set for the DB.GetOrderItems method")
	}

	if len(mmGetOrderItems.expectations) > 0 {
		mmGetOrderItems.mock.t.Fatalf("Some expectations are already set for the DB.GetOrderItems method")
	}

	mmGetOrderItems.mock.funcGetOrderItems = f
	return mmGetOrderItems.mock
}

// When sets expectation for the DB.GetOrderItems which will trigger the result defined by the following
// Then helper
func (mmGetOrderItems *mDBMockGetOrderItems) When(oid uint64) *DBMockGetOrderItemsExpectation {
	if mmGetOrderItems.mock.funcGetOrderItems != nil {
		mmGetOrderItems.mock.t.Fatalf("DBMock.GetOrderItems mock is already set by Set")
	}

	expectation := &DBMockGetOrderItemsExpectation{
		mock:   mmGetOrderItems.mock,
		params: &DBMockGetOrderItemsParams{oid},
	}
	mmGetOrderItems.expectations = append(mmGetOrderItems.expectations, expectation)
	return expectation
}

// Then sets up DB.GetOrderItems return parameters for the expectation previously defined by the When method
func (e *DBMockGetOrderItemsExpectation) Then(ua1 []uint64, err error) *DBMock {
	e.results = &DBMockGetOrderItemsResults{ua1, err}
	return e.mock
}

// GetOrderItems implements DB
func (mmGetOrderItems *DBMock) GetOrderItems(oid uint64) (ua1 []uint64, err error) {
	mm_atomic.AddUint64(&mmGetOrderItems.beforeGetOrderItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrderItems.afterGetOrderItemsCounter, 1)

	if mmGetOrderItems.inspectFuncGetOrderItems != nil {
		mmGetOrderItems.inspectFuncGetOrderItems(oid)
	}

	mm_params := &DBMockGetOrderItemsParams{oid}

	// Record call args
	mmGetOrderItems.GetOrderItemsMock.mutex.Lock()
	mmGetOrderItems.GetOrderItemsMock.callArgs = append(mmGetOrderItems.GetOrderItemsMock.callArgs, mm_params)
	mmGetOrderItems.GetOrderItemsMock.mutex.Unlock()

	for _, e := range mmGetOrderItems.GetOrderItemsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmGetOrderItems.GetOrderItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrderItems.GetOrderItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrderItems.GetOrderItemsMock.defaultExpectation.params
		mm_got := DBMockGetOrderItemsParams{oid}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrderItems.t.Errorf("DBMock.GetOrderItems got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrderItems.GetOrderItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrderItems.t.Fatal("No results are set for the DBMock.GetOrderItems")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmGetOrderItems.funcGetOrderItems != nil {
		return mmGetOrderItems.funcGetOrderItems(oid)
	}
	mmGetOrderItems.t.Fatalf("Unexpected call to DBMock.GetOrderItems. %v", oid)
	return
}

// GetOrderItemsAfterCounter returns a count of finished DBMock.GetOrderItems invocations
func (mmGetOrderItems *DBMock) GetOrderItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderItems.afterGetOrderItemsCounter)
}

// GetOrderItemsBeforeCounter returns a count of DBMock.GetOrderItems invocations
func (mmGetOrderItems *DBMock) GetOrderItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderItems.beforeGetOrderItemsCounter)
}

// Calls returns a list of arguments used in each call to DBMock.GetOrderItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrderItems *mDBMockGetOrderItems) Calls() []*DBMockGetOrderItemsParams {
	mmGetOrderItems.mutex.RLock()

	argCopy := make([]*DBMockGetOrderItemsParams, len(mmGetOrderItems.callArgs))
	copy(argCopy, mmGetOrderItems.callArgs)

	mmGetOrderItems.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderItemsDone returns true if the count of the GetOrderItems invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockGetOrderItemsDone() bool {
	for _, e := range m.GetOrderItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderItemsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderItemsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderItems != nil && mm_atomic.LoadUint64(&m.afterGetOrderItemsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOrderItemsInspect logs each unmet expectation
func (m *DBMock) MinimockGetOrderItemsInspect() {
	for _, e := range m.GetOrderItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.GetOrderItems with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderItemsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderItemsCounter) < 1 {
		if m.GetOrderItemsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.GetOrderItems")
		} else {
			m.t.Errorf("Expected call to DBMock.GetOrderItems with params: %#v", *m.GetOrderItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderItems != nil && mm_atomic.LoadUint64(&m.afterGetOrderItemsCounter) < 1 {
		m.t.Error("Expected call to DBMock.GetOrderItems")
	}
}

type mDBMockGetUserName struct {
	mock               *DBMock
	defaultExpectation *DBMockGetUserNameExpectation
	expectations       []*DBMockGetUserNameExpectation

	callArgs []*DBMockGetUserNameParams
	mutex    sync.RWMutex
}

// DBMockGetUserNameExpectation specifies expectation struct of the DB.GetUserName
type DBMockGetUserNameExpectation struct {
	mock    *DBMock
	params  *DBMockGetUserNameParams
	results *DBMockGetUserNameResults
	Counter uint64
}

// DBMockGetUserNameParams contains parameters of the DB.GetUserName
type DBMockGetUserNameParams struct {
	uid uint64
}

// DBMockGetUserNameResults contains results of the DB.GetUserName
type DBMockGetUserNameResults struct {
	s1  string
	err error
}

// Expect sets up expected params for DB.GetUserName
func (mmGetUserName *mDBMockGetUserName) Expect(uid uint64) *mDBMockGetUserName {
	if mmGetUserName.mock.funcGetUserName != nil {
		mmGetUserName.mock.t.Fatalf("DBMock.GetUserName mock is already set by Set")
	}

	if mmGetUserName.defaultExpectation == nil {
		mmGetUserName.defaultExpectation = &DBMockGetUserNameExpectation{}
	}

	mmGetUserName.defaultExpectation.params = &DBMockGetUserNameParams{uid}
	for _, e := range mmGetUserName.expectations {
		if minimock.Equal(e.params, mmGetUserName.defaultExpectation.params) {
			mmGetUserName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserName.defaultExpectation.params)
		}
	}

	return mmGetUserName
}

// Inspect accepts an inspector function that has same arguments as the DB.GetUserName
func (mmGetUserName *mDBMockGetUserName) Inspect(f func(uid uint64)) *mDBMockGetUserName {
	if mmGetUserName.mock.inspectFuncGetUserName != nil {
		mmGetUserName.mock.t.Fatalf("Inspect function is already set for DBMock.GetUserName")
	}

	mmGetUserName.mock.inspectFuncGetUserName = f

	return mmGetUserName
}

// Return sets up results that will be returned by DB.GetUserName
func (mmGetUserName *mDBMockGetUserName) Return(s1 string, err error) *DBMock {
	if mmGetUserName.mock.funcGetUserName != nil {
		mmGetUserName.mock.t.Fatalf("DBMock.GetUserName mock is already set by Set")
	}

	if mmGetUserName.defaultExpectation == nil {
		mmGetUserName.defaultExpectation = &DBMockGetUserNameExpectation{mock: mmGetUserName.mock}
	}
	mmGetUserName.defaultExpectation.results = &DBMockGetUserNameResults{s1, err}
	return mmGetUserName.mock
}

//Set uses given function f to mock the DB.GetUserName method
func (mmGetUserName *mDBMockGetUserName) Set(f func(uid uint64) (s1 string, err error)) *DBMock {
	if mmGetUserName.defaultExpectation != nil {
		mmGetUserName.mock.t.Fatalf("Default expectation is already set for the DB.GetUserName method")
	}

	if len(mmGetUserName.expectations) > 0 {
		mmGetUserName.mock.t.Fatalf("Some expectations are already set for the DB.GetUserName method")
	}

	mmGetUserName.mock.funcGetUserName = f
	return mmGetUserName.mock
}

// When sets expectation for the DB.GetUserName which will trigger the result defined by the following
// Then helper
func (mmGetUserName *mDBMockGetUserName) When(uid uint64) *DBMockGetUserNameExpectation {
	if mmGetUserName.mock.funcGetUserName != nil {
		mmGetUserName.mock.t.Fatalf("DBMock.GetUserName mock is already set by Set")
	}

	expectation := &DBMockGetUserNameExpectation{
		mock:   mmGetUserName.mock,
		params: &DBMockGetUserNameParams{uid},
	}
	mmGetUserName.expectations = append(mmGetUserName.expectations, expectation)
	return expectation
}

// Then sets up DB.GetUserName return parameters for the expectation previously defined by the When method
func (e *DBMockGetUserNameExpectation) Then(s1 string, err error) *DBMock {
	e.results = &DBMockGetUserNameResults{s1, err}
	return e.mock
}

// GetUserName implements DB
func (mmGetUserName *DBMock) GetUserName(uid uint64) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetUserName.beforeGetUserNameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserName.afterGetUserNameCounter, 1)

	if mmGetUserName.inspectFuncGetUserName != nil {
		mmGetUserName.inspectFuncGetUserName(uid)
	}

	mm_params := &DBMockGetUserNameParams{uid}

	// Record call args
	mmGetUserName.GetUserNameMock.mutex.Lock()
	mmGetUserName.GetUserNameMock.callArgs = append(mmGetUserName.GetUserNameMock.callArgs, mm_params)
	mmGetUserName.GetUserNameMock.mutex.Unlock()

	for _, e := range mmGetUserName.GetUserNameMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetUserName.GetUserNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserName.GetUserNameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserName.GetUserNameMock.defaultExpectation.params
		mm_got := DBMockGetUserNameParams{uid}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserName.t.Errorf("DBMock.GetUserName got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserName.GetUserNameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserName.t.Fatal("No results are set for the DBMock.GetUserName")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetUserName.funcGetUserName != nil {
		return mmGetUserName.funcGetUserName(uid)
	}
	mmGetUserName.t.Fatalf("Unexpected call to DBMock.GetUserName. %v", uid)
	return
}

// GetUserNameAfterCounter returns a count of finished DBMock.GetUserName invocations
func (mmGetUserName *DBMock) GetUserNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserName.afterGetUserNameCounter)
}

// GetUserNameBeforeCounter returns a count of DBMock.GetUserName invocations
func (mmGetUserName *DBMock) GetUserNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserName.beforeGetUserNameCounter)
}

// Calls returns a list of arguments used in each call to DBMock.GetUserName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserName *mDBMockGetUserName) Calls() []*DBMockGetUserNameParams {
	mmGetUserName.mutex.RLock()

	argCopy := make([]*DBMockGetUserNameParams, len(mmGetUserName.callArgs))
	copy(argCopy, mmGetUserName.callArgs)

	mmGetUserName.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserNameDone returns true if the count of the GetUserName invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockGetUserNameDone() bool {
	for _, e := range m.GetUserNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserName != nil && mm_atomic.LoadUint64(&m.afterGetUserNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUserNameInspect logs each unmet expectation
func (m *DBMock) MinimockGetUserNameInspect() {
	for _, e := range m.GetUserNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.GetUserName with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserNameCounter) < 1 {
		if m.GetUserNameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.GetUserName")
		} else {
			m.t.Errorf("Expected call to DBMock.GetUserName with params: %#v", *m.GetUserNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserName != nil && mm_atomic.LoadUint64(&m.afterGetUserNameCounter) < 1 {
		m.t.Error("Expected call to DBMock.GetUserName")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DBMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetOrderItemsInspect()

		m.MinimockGetUserNameInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DBMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DBMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetOrderItemsDone() &&
		m.MinimockGetUserNameDone()
}
